## 4.2 プロパティ

[変数](class-field-variable.md)に続き、プロパティがクラスにデータ持つ2番目の方法になります。変数とは異なり、プロパティはどのようなアクセスが許可されるかと、どのように生成されるかのより細かい制御が要求されます。よくある使い方は、例えば以下のようなものです。

* どこからでも読み込み可能だが、書き込みは定義しているクラスからのみのフィールドを作る
* 読み込みアクセスがされたときに**ゲッター**メソッドが実行されるフィールドを作る。
* 書き込みアクセスがされたときに**セッター**メソッドが実行されるフィールドを作る。

プロパティをあつかう場合、2種類のアクセスについて理解することが重要です。

> ##### Define: 読み込みアクセス
>
> 読み込みアクセスは右辺側で[フィールドアクセス式](expression-field-access.md)が使われると発生します。これには`obj.field()`の形の関数呼び出しもふくまれるため、この`field`も読み込みアクセスがされます。

> ##### Define: 書き込みアクセス
>
> フィールドへの書き込みアクセスは、[フィールドアクセス式](expression-field-access.md)に`obj.field = value`の形式で値の代入することで発生します。また、`obj.field += value`の式`+=`のような特殊な代入演算子を使うと、書き込みアクセスと[読み込みアクセス](dictionary.md#define-read-access)の両方が発生します。
 

読み込みアクセスと書き込みアクセスを以下の構文を使って直接指定します。

```haxe
class Main {
  public var x(default, null):Int;
  static public function main() { }
}
```

大部分は変数の構文と同じで、同じルールが適用されます。プロパティは以下の点で異なります。

* フィールド名の後から小かっこが始まります(`(`)。
* 次に、特殊な**アクセス識別子**が来ます(ここでは`default`)。
* カンマ(`,`)で区切ります。
* もう一つ特殊なアクセス識別子が続きます(ここでは`null`)。
* 小かっこを閉じます(`)`)。

1つ目のアクセス識別子はフィールドの読み込み、2つ目は書き込み時の挙動を決定します。アクセス識別子には以下の値が使用できます。

* `default`: フィールドの可視性が`public`の場合、通常のフィールドと同じです。その他の場合、`null`アクセスと同じです。
* `null`: 定義したクラスのみからアクセスできます。
* `get`/`set`: アクセス時に**アクセサメソッド**を呼び出します。コンパイラが使用可能なアクセサの存在を確認します。
* `dynamic`: `get`/`set`アクセスに似ていますが、アクセサフィールドの存在を確認しません。
* `never`: いかなるアクセスも許可しません。

> ##### Define: アクセサメソッド
>
> 型が`T`でフィールド名が`field`のフィールドに対する**アクセサメソッド**は、`Void->T`型のフィールド名`get_field`の**ゲッター**または`T->T`型のフィールド名`set_field`の**セッター**です。アクセサメソッドは略して**アクセサ**とも呼びます。

> ##### Trivia: アクセサ名
>
> Haxe 2では、アクセス識別子に自由な識別子を使うことが可能で、その場合はそれがカスタムのアクセサメソッド名となっていました。しかし、これにより実装は変則的なものになっていました。例えば、`Reflect.getProperty()`と`Reflect.setProperty()`はどのような名前が名前が使われていたとしても対応する必要がありました。そのため、ターゲット出力時に参照のためのメタ情報を生成する必要がありました。
> 
> この識別子の名前を`get_`、`set_`から始まるもののみに制限することで、実装を大きく簡略化することに成功しました。これがHaxe 2と3の間の破壊的な変更の1つです。

---

Previous section: [変数](class-field-variable.md)

Next section: [よくあるアクセス識別子の組み合わせ](class-field-property-common-combinations.md)