## 8.2 デッドコード削除

デッドコード削除(Dead Code Elimination、**DCE**)は、未使用のコードを出力から取り除くコンパイラ機能です。型付けの後に、デッドコード削除の始点（多くの場合はmainメソッド）から再帰的にたどっていき、どのフィールドと型が使用されているかを決定します。これにより使用済みのフィールドはマークされ、マークされていないフィールドはクラスから取り除かれます。

デッドコード削除には3つのモードがあり、コマンドラインからの呼び出し時に指定します。

* -dce std: Haxeの標準ライブラリのクラスのみがデッドコード削除の影響を受けます。これがすべてのターゲットでのデフォルト値です。
* -dce no: デッドコード削除されません。
* -dce full: すべてのクラスがデッドコード削除の影響を受けます。

デッドコード削除のアルゴリズムは型付けされたコードではうまく働きますが、[Dynamic](types-dynamic.md)や[リフレクション](std-reflection.md)を使っていると失敗する場合があります。そのような場合は、以下のメタデータを使ったクラスやフィールドの明示的な修飾が有効かもしれません。

* `@:keep`: クラスに使用するとすべてのフィールドがデッドコード削除の対象から除外されます。フィールドに使用するとそのフィールドがデッドコード削除の対象になりません。
* `@:keepSub`: クラスに使用すると、その子孫クラスすべてを`@:keep`で修飾したのと同様の動作をします。
* `@:keepInit`: 通常、クラスはすべてのフィールドがデッドコード削除によって削除されると（あるいは最初から空だと）出力から削除されます。このメタデータを使うと、空のクラスが保護されます。

ソースコードを編集するのではなくコマンドラインからクラスを`@:keep`としてマークしたい場合、コンパイラマクロの`--macro keep('type dot path')`を使うことでそれが可能です。このマクロについて詳しくは[haxe.macro.Compiler.keep API](http://api.haxe.org/haxe/macro/Compiler.html#keep)をご覧ください。パッケージをマークするとそのモジュールやサブタイプがデッドコード削除から保護されて、コンパイルに含まれます。

コンパイラは現在のモードに応じて、自動的に`dce`フラグの値を`"std"`、`"no"`、`"full"`のいずれかに設定します。このフラグは[条件付きコンパイル](lf-condition-compilation.md)で使用できます。

> ##### Trivia: デッドコード削除の書き直し
>
> 
> デッドコード削除は元々Haxe 2.07で実装されましたが、その実装では関数が明示的に型付けされると使用されているという判定がされていました。このせいでいくつか機能で問題がありました。型安全性を確かめるためにすべてのクラスフィールドを型付けする必要があるインタフェースでとくに深刻でした。このせいでデッドコード削除は完全に破たんし、Haxe 2.10での書き直しにつながりました。

> ##### Trivia: デッドコード削除とtry.haxe.org
>
> <http://try.haxe.org>のサイトが公開されたとき、`JavaScript`ターゲットのデッドコード削除は大きく改善されました。JavaScriptの出力コードに対する反応はさまざまでしたが、これにより削除されるコードの選択がより細かく行われるようになりました。

---

Previous section: [ビルトインのコンパイラメタデータ](cr-metadata.md)

Next section: [コンパイラサービス](cr-completion.md)