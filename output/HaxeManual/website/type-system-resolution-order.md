## 3.7.3 解決順序

不適切な識別子が入り組んでいる場合には、解決順序があらわれます。[式](expression.md)には、`foo()`、`foo = 1`、`foo.field`の形があり、とくに最後の形では、`haxe`が不適切な識別子な場合の`haxe.ds.StringMap`のようなモジュールのパスの可能性もふくんでいます。

これがその解決順序のアルゴリズムです。以下の各状態が影響しています。

* 宣言されている[ローカル変数](expression-var.md) (関数の引数もふくむ)
* [インポート](type-system-import.md) されたモジュール、型、静的フィールド。
* 利用可能な[静的拡張](lf-static-extension.md)
* 現在のフィールドの種類(静的フィールドなのか、メンバフィールドなのか) 
* 現在のクラスと親クラスで定義されている、メンバフィールド
* 現在のクラスで定義されている、静的フィールド
* [期待される型](dictionary.md#define-expected-type)
* `untyped`中の式か、そうでないか

<img src="../../assets/graphics/generated/type-system-resolution-order-diagram.png" alt="識別子 `i'　の解決順序" title="識別子 `i'　の解決順序" />

_Figure: 識別子 `i'　の解決順序_

`i`を例にすると、このアルゴリズムは以下のようなものです。

1. `i`が`true`、`false`、`this`、`super`、`null`のいずれかの場合、その定数として解決されて終了。
2. `i`というローカル変数があった場合、それに解決されて終了。
3. 現在いるフィールドが、静的フィールドであれば、6に進む。
4. 現在のクラスか、いずれかの親クラスで`i`のメンバフィールドが定義されている場合、それに解決されて終了。
5. 静的拡張の第1引数として現在のクラスのインスタンスが利用可能な場合、それに解決されて終了。
6. 現在のクラスが`i`という静的フィールドを持っている場合、それに解決されて終了。
7. インポート済みのenumに`i`というコンストラクタがあった場合、それに解決されて終了。
8. `i`という名前の静的フィールドが明示的にインポートされていた場合 それに解決されて終了。
9. `i`が小文字から始まる場合、11に進む。
10. `i`という型が利用可能な場合、それに解決されて進む。
11. 式が`untyped`中にいない場合、14に進む。
12. `i`が`__this__`の場合、`this`として解決されて終了。
13. ローカル変数の`i`を生成し、それに解決されて終了。
14. 失敗

10のステップについて、型の解決順序の定義も必要です。

1. `i`がインポートされている場合(直接か、モジュールの一部としてか、にかかわらず)、それに解決されて終了。
2. 現在のパッケージが`i`という名前モジュールの`i`という型をふくんでいる場合、それに解決されて終了。
3. `i`がトップレベルで利用可能な場合、それに解決されて終了。
4. 失敗

このアルゴリズムの1のステップと、式の場合の5と7
のステップでは、以下のインポートの解決順序も重要です。

* インポートしたモジュールと静的拡張は、下から上へとチェックされて最初にマッチしたものが使われます。
* 一つのモジュールの中では、型は上から下へとチェックされていきます。
* インポートでは、名前が一致した場合ににマッチしたものとなります。
* [静的拡張](lf-static-extension.md)では、名前が一致して、なおかつ最初の引数が[単一化](type-system-unification.md)できると、マッチが成立します。静的拡張として使われる一つの型の中では、フィールドは上から下へとチェックされます

---

Previous section: [インポート(import)](type-system-import.md)

Next section: [Class Fields](class-field.md)