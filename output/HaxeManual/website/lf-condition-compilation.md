## 6.1 条件付きコンパイル

Haxeでは、`#if`、`#elseif`、`#else`を使って**コンパイラフラグ**を確認することで条件付きコンパイルが可能です。

> ##### Define: コンパイラフラグ
>
> コンパイラフラグはコンパイルの過程に影響をあたえる、設定可能な値です。このフラグは`-D key=value`あるいは単に`-D key`（この場合デフォルト値の`"1"`になる）の形式でコマンドラインから指定できます。そのほかにも、コンパイラはコンパイルの過程で別のステップへ情報伝達するために、内部的にいくつかのフラグを設定します。

以下は条件付きコンパイルの利用例のデモです。

```haxe
class Main {
  public static function main(){
    #if !debug
      trace("ok");
    #elseif (debug_level > 3)
      trace(3);
    #else
      trace("debug level too low");
    #end
  }
}
```

これをフラグ無しでコンパイルした場合、`main`メソッドの`trace("ok");`が実行されて終了します。他の分岐はファイルを構文解析する際に切り捨てられます。他の分岐についても、正しいHaxeの構文である必要がありますが、型チェックはされません。

`#if`と`#elseif`の直後の条件には以下の式が使えます。

* すべての識別子は同名のコンパイラフラグの値で置きかえられます。コマンドラインから`-D some-flag`を指定すると`some-flag`と`some_flag`のフラグが定義されることに気を付けてください。
* `String`、`Int`、`Float`の定数値は直接使用されます。
* `Bool`の演算`&&` (and)、`||` (or)、`!` (not) は期待どおりに動作しますが、式全体を小かっこでかこむ必要があります。
* `==`、`!=`、`>`、`>=`、`<`、`<=`の演算子が値の比較に使えます。
* 小かっこ`()`は通常通り、式をグループ化するのに使えます。

Haxeの構文解析器は`some-flag`を一つの句として認識しません、`some - flag`の2項演算として読み取ります。このような場合はアンダースコアを使う`some_flag`の版を使用する必要があります。

##### ビルトインのコンパイラフラグ

ビルトインのコンパイラフラグの完全なリストはHaxeコンパイラを`--help-defines`の引数をつけて呼び出すことで手に入れることができます。Haxeのコンパイラはコンパイルごとに複数の`-D`フラグを指定できます。

[コンパイラフラグ一覧](lf-condition-compilation-flags.md)も確認してみてください。

---

Previous section: [言語機能](lf.md)

Next section: [グローバルコンパイラフラグ](lf-condition-compilation-flags.md)
