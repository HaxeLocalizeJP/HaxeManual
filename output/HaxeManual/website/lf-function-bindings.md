## 6.8 関数の束縛(bind)

Haxe3では、部分的に引数を適用して関数を束縛することが可能です。すべての関数型は`bind`フィールドを持っており、これを呼び出すことで引数の数を減らした新しい関数を作りだすことができます。その実例を示します。

```haxe
class Main {
  static public function main() {
    var map = new haxe.ds.IntMap<String>();
    var f = map.set.bind(_, "12");
    $type(map.set); // Int -> String -> Void
    $type(f); // Int -> Void
    f(1);
    f(2);
    f(3);
    trace(map); // {1 => 12, 2 => 12, 3 => 12}
  }
}

```

行4では、`map.set`関数に2番目の引数に`12`を適用し、`f`という変数に割り当てました。アンダースコア(`_`)はその引数を束縛しないことを表すのに使います。このことは`map.set`と、`f`の型の比較でもわかります。束縛された`String`型の引数が取り除かれたので、`Int->String->Void`型が`Int->Void`型に変わっています。

`f(1)`を呼び出したことで実際には`map.set(1, "12")`が実行されます。`f(2)`、`f(3)`の呼び出しでも同じ関係性が成り立ちます。最後の行で、3つのインデックスすべてに紐づく値が`"12"`になっていることが確認できます。

アンダースコア(`_`)は末尾の引数では省略することができます。つまり、`map.set.bind(1)`で最初の引数を束縛した場合、インデックス`1`について新しい値を設定する`String->Void`関数が提供されます。

> ##### Trivia: コールバック
>
> Haxe3よりも前のバージョンでは、`callback`キーワードに1つの関数の引数と任意の個数の束縛する引数をつけて呼び出しをしていました。この束縛する機能に対してコールバック関数という名前が使われるようになっていました。
> 
> `callback`は左から右への束縛のみでアンダースコア(`_`)はサポートしていませんでした。アンダースコアを使うという選択肢は論争を生み、そのほかの案もいくつか現れましたがこれより優れているものはありませんでした。少なくともアンダースコア(`_`)は「ここに値を入れて」と言っているように見えるので、この意味を書き表すのに適しているという結論にいたりました。

---

Previous section: [イテレータ(反復子)](lf-iterators.md)

Next section: [メタデータ](lf-metadata.md)