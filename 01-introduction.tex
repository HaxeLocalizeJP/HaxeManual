\chapter{導入}
\label{introduction}
\state{NoContent}

\section{Haxeって何?}
\label{introduction-what-is-haxe}

\todo{Could we have a big Haxe logo in the First Manual Page (Introduction) under the menu (a bit like a book cover ?) It looks a bit empty now and is a landing page for "Manual"}

Haxeはオープンソースの高級プログラミング言語とコンパイラで構成されており、ECMAScript\footnote{http://www.ecma-international.org/publications/standards/Ecma-327.htm}をもとにした構文で書いたプログラムをさまざまなターゲットの言語へとコンパイルすることを可能にします。適度な抽象化をしてやれば、複数のターゲットへコンパイル可能な1つのコードベースを作成できます。

Haxeは強く型付けされている一方で、必要に応じて型付けを弱めることも可能です。型情報を活用すれば、ターゲットの言語では実行時にしか発見できないようなエラーをコンパイル時に検出することができます。さらには、ターゲットへの変換時に最適化や堅牢なコードを生成するためにも使用されます。

現在、Haxeには9つのターゲット言語があり、さまざまな用途に利用できます。

\begin{center}
\begin{tabular}{| l | l | l |}
	\hline
	名前 & 出力形式 & 主な用途 \\ \hline
	JavaScript & ソースコード & ブラウザ, デスクトップ, モバイル, サーバー \\
	Neko & バイトコード & デスクトップ, サーバー \\
	PHP & ソースコード & サーバー \\
	Python & ソースコード & デスクトップ, サーバー \\
	C++ & ソースコード & デスクトップ, モバイル, サーバー \\
	ActionScript 3 & ソースコード & ブラウザ, デスクトップ, モバイル \\
	Flash & バイトコード & ブラウザ, デスクトップ, モバイル \\ 
	Java & ソースコード & デスクトップ, サーバー \\
	C\# & ソースコード & デスクトップ, モバイル, サーバー \\ \hline
\end{tabular}
\end{center}

この\Fullref{introduction}の残りでは、Haxeのプログラムがどのようなものなのか、Haxeは2005年に生まれてからどのように進化してきたのか、を概要でお送りします。

\Fullref{types}では、Haxeの7種類の異なる型についてとそれらがどう関わりあっているのかについて紹介します。型に関する話は、\Fullref{type-system}へと続き、\emph{単一化(Unification)}, \emph{型パラメータ}, \emph{型推論}についての解説がされます。

\Fullref{class-field}では、Haxeのクラスの構造に関する全てをあつかいます。加えて、\emph{プロパティ}, \emph{インラインフィールド}, \emph{ジェネリック関数}についてもあつかいます。

\Fullref{expression}では、\emph{式}を使用して実際にいくつかの動作をさせる方法をお見せします。

\Fullref{lf}では、\emph{パターンマッチング}, \emph{文字列補間}, \emph{デッドコード削除}のようなHaxeの詳細の機能について記述しています。ここで、Haxeの言語リファレンスは終わりです。

そして、Haxeのコンパイラリファレンスへと続きます。まずは\Fullref{compiler-reference}で基本的な内容を、そして、\Fullref{cr-features}で高度な機能をあつかいます。最後に\Fullref{macro}で、ありふれたタスクを\emph{Haxeマクロ}がどのように単純かするのかを見ながら、刺激的なマクロの世界に挑んでいきます。

次の\Fullref{std}のでは、Haxeの標準ライブラリに含まれる主要な型や概念を一つ一つ見ていきます。そして、\Fullref{haxelib}でHaxeのパッケージマネージャであるHaxelibについて学びます。

Haxeは様々なターゲット間の差を吸収してくれますが、場合によってはターゲットを直接的にあつかうことが重要になります。これが、\Fullref{target-details}の話題です。

\section{このドキュメントについて}
\label{introduction-about-this-document}

このドキュメントは、Haxe3の公式マニュアル（の非公式日本語訳）です。そのため、初心者向けののチュートリアルではなく、プログラミングは教えません。しかし、項目は大まかに前から順番に読めるように並べてあり、前に出てきた項目と、次に出てくる項目との関連づけがされています。先の項目で後の項目でててくる情報に触れた方が説明しやすい場所では、先にその情報に触れています。そのような場面ではリンクがされています。リンク先は、ほとんどの場合で先に読むべき内容ではありません。

このドキュメントでは、理論的な要素を実物としてつなげるために、たくさんのHaxeのソースコードを使います。これらのコードのほとんどはmain関数を含む完全なコードでありそのままコンパイルが可能ですが、いくつかはそうではなくコードの重要な部分の抜き出しです。

ソースコードは以下のように示されます：

\begin{lstlisting}
Haxe code here
\end{lstlisting}

時々、Haxeがどのようなコードを出力をするかを見せるため、ターゲットの\target{JavaScript}などのコードも示します。

さらに、このドキュメントではいくつかの単語の定義を行います。定義は主に、新しい型やHaxe特有の単語を紹介するときに行われます。私たちが紹介するすべての新しい内容に対して定義をするわけではありません(例えば、クラスの定義など)。

定義は以下のように示されます。

\define{定義の名前}{define-definition}{定義の説明}

また、いくつかの場所には\emph{トリビア}欄を用意してます。トリビア欄では、Haxeの開発過程でどうしてそのような決定がなされたのか、なぜその機能が過去のHaxeのバージョンから変更されたのかなど非公開の情報をお届けします。この情報は一般的には重要ではない、些細な内容なので読み飛ばしても構いません。

\trivia{トリビアについて}{これはトリビアです}

\subsection{著者と貢献者}
\label{introduction-authors-and-contributions}

このドキュメントの大半の内容は、Haxe Foundationで働くSimon Krajewskiによって書かれました。そして、このドキュメントの貢献者である以下の方々に感謝の意を表します。

\begin{itemize}
	\item Dan Korostelev: 追加の内容と編集
	\item Caleb Harper: 追加の内容と編集
	\item Josefiene Pertosa: 編集
	\item Miha Lunar: 編集
	\item Nicolas Cannasse: Haxe創始者
\end{itemize}



\section{Hello World}
\label{introduction-hello-world}

The following program prints ``Hello World'' after being compiled and run:

\haxe{assets/HelloWorld.hx}
This can be tested by saving the above code to a file named \ic{HelloWorld.hx} and invoking the Haxe Compiler like so: \ic{haxe -main HelloWorld --interp}. It then generates the following output: \ic{HelloWorld.hx:3: Hello world}. There are several things to learn from this:
\todo{This generates the following output: too many 'this'. You may like a passive sentence: the following output will be generated...though this is to be avoided, generally}

\begin{itemize}
	\item Haxe programs are saved in files with an extension of \ic{.hx}.
	\item The Haxe Compiler is a command-line tool which can be invoked with parameters such as \ic{-main HelloWorld} and \ic{--interp}.
	\item Haxe programs have classes (\type{HelloWorld}, upper-case), which have functions (\expr{main}, lower-case). 
\end{itemize}

\section{History}
\label{introduction-haxe-history}
\state{Reviewed}

The Haxe project was started on 22 October 2005 by French developer \emph{Nicolas Cannasse} as a successor to the popular open-source ActionScript 2 compiler \emph{MTASC} (Motion-Twin Action Script Compiler) and the in-house \emph{MTypes} language, which experimented with the application of type inference to an object oriented language. Nicolas' long-time passion for programming language design and the rise of new opportunies to mix different technologies as part of his game developer work at \emph{Motion-Twin} led to the creation of a whole new language.

Being spelled \emph{haXe} back then, its beta version was released in February 2006 with the first supported targets being AVM\footnote{Adobe Virtual Machine}-bytecode and Nicolas' own \emph{Neko} virtual machine\footnote{http://nekovm.org}.

Nicolas Cannasse, who remains leader of the Haxe project to this date, kept on designing Haxe with a clear vision, subsequently leading to the Haxe 1.0 release in May 2006. This first major release came with support for \target{Javascript} code generation and already had some of the features that define Haxe today such as type inference and structural sub-typing.

Haxe 1 saw several minor releases over the course of two years, adding the \target{Flash AVM2} target along with the \emph{haxelib}-tool in August 2006 and the \target{Actionscript 3} target in March 2007. During these months, there was a strong focus on improving stability, which resulted in several minor bug-fix releases.

Haxe 2.0 was released in July 2008, including the \target{PHP} target, courtesy of \emph{Franco Ponticelli}. A similar effort by \emph{Hugh Sanderson} lead to the addition of the \target{C++} target in July 2009 with the Haxe 2.04 release.

Just as with Haxe 1, what followed were several months of stability releases. In January 2011, Haxe 2.07 was released with the support of \emph{macros}. Around that time, \emph{Bruno Garcia} joined the team as maintainer of the \target{Javascript} target, which saw vast improvements in the subsequent 2.08 and 2.09 releases.

After the release of 2.09, \emph{Simon Krajewski} joined the team and work towards Haxe 3 began. Furthermore, \emph{Cau\^{e} Waneck}'s \target{Java} and \target{C\#} targets found their way into the Haxe builds. It was then decided to make one final Haxe 2 release, which happened in July 2012 with the release of Haxe 2.10.

In late 2012, the Haxe 3 switch was flipped and the Haxe Compiler team, now backed by the newly established \emph{Haxe Foundation}\footnote{http://haxe-foundation.org}, focused on this next major version. Haxe 3 was subsequently released in May 2013.
