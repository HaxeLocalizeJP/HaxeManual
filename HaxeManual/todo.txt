This file is generated, do not edit!

Todo:
1.1 - Haxeって何?: Could we have a big Haxe logo in the First Manual Page (Introduction) under the menu (a bit like a book cover ?) It looks a bit empty now and is a landing page for "Manual"
1.3 - Hello World: This generates the following output: too many 'this'. You may like a passive sentence: the following output will be generated...though this is to be avoided, generally
2.1.3 - 数値の演算子: make sure the types are right for inc, dec, negate, and bitwise negate
2.1.3 - 数値の演算子: While introducing the different operations, we should include that information as well, including how they differ with the "C" standard, see http://haxe.org/manual/operators
2.1.5 - Void: please review, doubled content
2.1.5 - Void: review please, sounds weird
<<<<<<< HEAD:todo.txt
2.2 - Nullable(null許容型): for starters...please review
2.2.1 - オプション引数とnull許容: Is there a difference between `?y : Int` and `y : Null<Int>` or can you even do the latter? Some more explanation and examples with native optional and Haxe optional arguments and how they relate to nullability would be nice.
2.3 - クラスインスタンス: please review future tense
2.4 - 列挙型インスタンス: Same as in 2.2, what is `Enum<T>` syntax?
2.4.1 - 列挙型のコンストラクタ: list arguments
2.5 - 匿名の構造体: please reformat
2.5.3 - オプションのフィールド: I don't really know how these work yet.
2.6 - 関数型: It seems a bit convoluted explanations. Should we maybe start by "decoding" the meaning of  Void -> Void, then Int -> Bool -> Float, then maybe have samples using $type
2.8.2 - 演算子オーバーロード: please review for correctness
2.8.3 - 配列アクセス: You have marked "Map" for some reason
3.5 - 単一化(ユニフィケーション): Mention toString()/String conversion somewhere in this chapter.
3.5.1 - クラスとインターフェースの単一化: "parent class" should probably be used here, but I have no idea what it means, so I will refrain from changing it myself.
3.7.2 - Import: Describe import a.*
=======
2.2 - Nullability: for starters...please review
2.2.1 - Optional Arguments and Nullability: Is there a difference between `?y : Int` and `y : Null<Int>` or can you even do the latter? Some more explanation and examples with native optional and Haxe optional arguments and how they relate to nullability would be nice.
2.3 - Class Instance: please review future tense
2.4 - Enum Instance: Same as in 2.2, what is `Enum<T>` syntax?
2.4.1 - Enum Constructor: list arguments
2.5 - Anonymous Structure: please reformat
2.5.3 - Optional Fields: I don't really know how these work yet.
2.6 - Function Type: It seems a bit convoluted explanations. Should we maybe start by "decoding" the meaning of  Void -> Void, then Int -> Bool -> Float, then maybe have samples using $type
2.8.1 - Implicit Casts: please review your use of "this" and try to vary somewhat to avoid too much word repetition
2.8.2 - Operator Overloading: please review for correctness
2.8.3 - Array Access: You have marked "Map" for some reason
3.5 - Unification: Mention toString()/String conversion somewhere in this chapter.
3.5.1 - Between Class/Interface: "parent class" should probably be used here, but I have no idea what it means, so I will refrain from changing it myself.
>>>>>>> english/master:HaxeManual/todo.txt
3.7.3 - Resolution Order: proper label and caption + code/identifier styling for diagram
6.4.10 - Exhaustiveness checks: Figure out wtf our rules are now for when this is checked.
6.6 - Array Comprehension: Comprehensions are only listing Arrays, not Maps
8.4.1 - Embedding resources: what to use for listing of non-haxe code like hxml?
9.5.1 - Enum building: Check if we can build GADTs this way.
10.4.3 - Integer Math: I think C++ can use integer operatins, but I don't know about any other targets. Only saw this mentioned in an old discussion thread, still true?

Missing Content:
2.5.3 - オプションのフィールド
5.3 - Binary Operators
5.4 - Unary Operators
9.6.1 - Macro-in-Macro
9.6.4 - Type Parameters
10.10 - Xml
10.11 - Input/Output
10.12 - Sys/sys
12.3 - Neko
12.5.2 - Using C++ Pointers
12.6 - Java
12.7 - C#

Unreviewed:
<<<<<<< HEAD:todo.txt
1.1 - Haxeって何?
1.2 - このドキュメントについて
1.2.1 - 著者と貢献者
=======
1.1 - What is Haxe?
1.2 - About this Document
1.2.1 - Authors and contributions
1.2.2 - License
>>>>>>> english/master:HaxeManual/todo.txt
1.3 - Hello World
2 - 型
2.1 - 基本型
2.1.1 - 数値型
2.1.2 - オーバーフロー
2.1.3 - 数値の演算子
2.1.4 - Bool(真偽値)
2.1.5 - Void
2.2 - Nullable(null許容型)
2.2.1 - オプション引数とnull許容
2.3 - クラスインスタンス
2.3.1 - クラスのコンストラクタ
2.3.2 - 継承
2.3.3 - インターフェース
2.4 - 列挙型インスタンス
2.4.1 - 列挙型のコンストラクタ
2.4.2 - 列挙型を使う
2.5 - 匿名の構造体
2.5.1 - JSONで構造体を書く
2.5.2 - 構造体の型のクラス記法
2.5.4 - パフォーマンスへの影響
2.6 - 関数型
2.6.1 - オプション引数
2.6.2 - デフォルト値
2.7 - ダイナミック
2.7.1 - 型パラメータ付きのダイナミック
2.7.2 - ダイナミックを実装(implements)する
2.8 - 抽象型(abstract)
2.8.1 - 暗黙のキャスト
2.8.2 - 演算子オーバーロード
2.8.3 - 配列アクセス
2.8.4 - 選択的関数
2.8.5 - 抽象型列挙体
2.8.6 - 抽象型フィールドの繰り上げ
2.8.7 - コアタイプの抽象型
2.9 - 単相型
3 - 型システム
3.1 - typedef
3.1.1 - 拡張
3.2 - 型パラメータ
3.2.1 - 制約
3.3 - ジェネリック
3.3.1 - ジェネリック型パラメータのコンストラクト
3.4 - 変性(バリアンス)
3.5 - 単一化(ユニフィケーション)
3.5.1 - クラスとインターフェースの単一化
3.5.2 - 構造的部分型付け
3.5.3 - 単相
3.5.4 - 関数の戻り値
3.5.5 - 共通の基底型
3.6 - Type Inference
3.6.1 - Top-down Inference
3.6.2 - Limitations
3.7 - Modules and Paths
3.7.1 - Module Sub-Types
3.7.2 - Import
3.7.3 - Resolution Order
4 - Class Fields
4.1 - Variable
4.2 - Property
4.2.1 - Common accessor identifier combinations
4.2.2 - Impact on the type system
4.2.3 - Rules for getter and setter
4.3 - Method
4.3.1 - Overriding Methods
4.3.2 - Effects of variance and access modifiers
4.4.1 - Visibility
4.4.2 - Inline
4.4.3 - Dynamic
4.4.4 - Override
5 - Expressions
5.1 - Blocks
5.2 - Constants
5.5 - Array Declaration
5.6 - Object Declaration
5.7 - Field Access
5.8 - Array Access
5.9 - Function Call
5.10 - var
5.11 - Local functions
5.12 - new
5.13 - for
5.14 - while
5.15 - do-while
5.16 - if
5.17 - switch
5.18 - try/catch
5.19 - return
5.20 - break
5.21 - continue
5.22 - throw
5.23 - cast
5.23.1 - unsafe cast
5.23.2 - safe cast
5.24 - type check
6.1 - Conditional Compilation
6.1.1 - Global Compiler Flags
6.2 - Externs
6.3 - Static Extension
6.3.1 - In the Haxe Standard Library
6.4.1 - Introduction
6.4.2 - Enum matching
6.4.3 - Variable capture
6.4.4 - Structure matching
6.4.5 - Array matching
6.4.6 - Or patterns
6.4.7 - Guards
6.4.8 - Match on multiple values
6.4.9 - Extractors
6.4.10 - Exhaustiveness checks
6.4.11 - Useless pattern checks
6.5 - String Interpolation
6.6 - Array Comprehension
6.7 - Iterators
6.8 - Function Bindings
6.9 - Metadata
6.10 - Access Control
6.11 - Inline constructors
7 - Compiler Usage
8.1 - Built-in Compiler Metadata
8.2 - Dead Code Elimination
8.3.1 - Overview
8.3.2 - Field access completion
8.3.3 - Call argument completion
8.3.4 - Type path completion
8.3.5 - Usage completion
8.3.6 - Position completion
8.3.7 - Top-level completion
8.3.8 - Completion server
8.4 - Resources
8.4.1 - Embedding resources
8.4.2 - Retrieving text resources
8.4.3 - Retrieving binary resources
8.4.4 - Implementation details
8.5 - Runtime Type Information
8.5.1 - RTTI structure
9 - Macros
9.1 - Macro Context
9.2 - Arguments
9.2.1 - ExprOf
9.2.2 - Constant Expressions
9.2.3 - Rest Argument
9.3 - Reification
9.3.1 - Expression Reification
9.3.2 - Type Reification
9.3.3 - Class Reification
9.4 - Tools
9.5 - Type Building
9.5.1 - Enum building
9.5.2 - @:autoBuild
9.5.3 - @:genericBuild
9.6.2 - Static extension
9.6.3 - Build Order
9.7 - Initialization macros
10.1 - String
10.2.1 - Array
10.2.2 - Vector
10.2.3 - List
10.2.4 - GenericStack
10.2.5 - Map
10.2.6 - Option
10.3 - Regular Expressions
10.3.1 - Matching
10.3.2 - Groups
10.3.3 - Replace
10.3.4 - Split
10.3.5 - Map
10.3.6 - Implementation Details
10.4 - Math
10.4.1 - Special Numbers
10.4.2 - Mathematical Errors
10.4.3 - Integer Math
10.4.4 - Extensions
10.5 - Lambda
10.6 - Template
10.7 - Reflection
10.8 - Serialization
10.8.1 - Serialization format
10.9 - Json
10.9.1 - Parsing JSON
10.9.2 - Encoding JSON
10.9.3 - Implementation details
10.13 - Remoting
10.13.1 - Remoting Connection
10.13.2 - Implementation details
10.14 - Unit testing
11 - Haxelib
11.1 - Using a Haxe library with the Haxe Compiler
11.2 - haxelib.json
11.2.1 - Versioning
11.2.2 - Dependencies
11.3 - extraParams.hxml
11.4 - Using Haxelib
12.1.1 - Getting started with Haxe/Javascript
12.1.2 - Using external Javascript libraries
12.1.3 - Javascript target Metatags
12.1.4 - Exposing Haxe classes for Javascript
12.1.5 - Loading extern classes using "require" function
12.2.1 - Getting started with Haxe/Flash
12.2.2 - Embedding resources
12.2.3 - Using external Flash libraries
12.2.4 - Flash target Metatags
12.4.1 - Getting started with Haxe/PHP
12.5.1 - Using C++ Defines

Modified:
