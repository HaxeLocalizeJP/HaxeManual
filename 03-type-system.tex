\chapter{型システム}
\label{type-system}

私たちは\Fullref{types}の章でさまざまな種類の型について学んできました。ここからはそれらがお互いにどう関連しあっているかを見ていく時間です。まず、複雑な型に対して名前(別名)を与える仕組みである\tref{Typedef}{type-system-typedef}の紹介から簡単に始めます。typedefは特に、\tref{型パラメータ}{type-system-type-parameters}を持つ型で役に立ちます。

任意の2つの型について、その上位にある型のグループが矛盾しないかをチェックすることで多くの型安全性が得られます。これがコンパイラが試みる\emph{単一化}であり、\Fullref{type-system-unification}の節で詳しく説明します。

すべての型は\emph{モジュール}に所属し、\emph{パス}を通して呼び出されます。\Fullref{type-system-modules-and-paths}では、これらに関連した仕組みについて詳しい説明を行います。

\section{Typedef}
\label{type-system-typedef}

typedefは\tref{匿名構造体}{types-anonymous-structure}の節で、すでに登場しています。そこでは複雑な構造体の型について名前を与えて簡潔にあつかう方法を見ています。この利用法はtypedefが一体なにに良いのかを的確に表しています。構造体の型に対して名前を与えるのは、typedefの主たる用途かもしれません。実際のところ、この用途が一般的すぎて、多くのHaxeユーザーがtypdefを構造体のためのものだと思ってしまっています。

typedefは他のあらゆる型に対して名前を与えることが可能です。

\begin{lstlisting}
typedef IA = Array<Int>;
\end{lstlisting}

これにより\expr{Array$<$Int$>$}が使われる場所で、代わりに\expr{IA}を使うことが可能になります。この場合、はほんの数回のタイプ数しか減らせませんが、より複雑な複合型の場合は違います。これこそが、typedefと構造体が強く結びついて見える理由です。

\begin{lstlisting}
typedef User = {
    var age : Int;
    var name : String;
}
\end{lstlisting}

typedefはテキスト上の置き換えではなく、実は本物の型です。Haxe標準ライブラリの\type{Iterable}のように\tref{型パラメータ}{type-system-type-parameters}を持つことができます。

\begin{lstlisting}
typedef Iterable<T> = {
	function iterator() : Iterator<T>;
}
\end{lstlisting}

\subsection{拡張}
\label{type-system-extensions}

% TODO: move to structures? %

拡張は、構造体が与えられた型のフィールドすべてと、加えていくつかのフィールドを持っていることを表すために使われます。

\haxe{assets/Extension.hx}
大なりの演算子を使うことで、追加のクラスフィールドを持つ\type{Iterable$<$T$>$}の拡張が作成されました。このケースでは、読み込み専用の\tref{プロパティ}{class-field-property} である\type{Int}型の\expr{length}が要求されます。 

\type{IterableWithLength$<$T$>$}に適合するためには、\type{Iterable$<$T$>$}にも適合してさらに読み込み専用の\type{Int}型のプロパティ\expr{length}を持ってなきゃいけません。例では、Arrayが割り当てられており、これはこれらの条件をすべて満たしています。

\since{3.1.0}

複数の構造体を拡張することもできます。

\haxe{assets/Extension2.hx}

\section{型パラメータ}
\label{type-system-type-parameters}

\tref{クラスフィールド}{class-field}や\tref{列挙型コンストラクタ}{types-enum-constructor}のように、Haxeではいくつかの型についてパラメータ化を行うことができます。型パラメータは山カッコ\expr{$<>$}内にカンマ区切りで記述することで、定義することができます。シンプルな例は、Haxe標準ライブラリの\type{Array}です。

\begin{lstlisting}
class Array<T> {
	function push(x : T) : Int;
}
\end{lstlisting}
\type{Array}のインスタンスが作られると、型パラメータ\type{T}は単相となります。つまり、1度に1つの型であれば、あらゆる型を適用することができます。この適用は以下の方法で行います

\begin{description}
	\item[明示的に、]\expr{new Array$<$String$>$()}のように型を記述してコンストラクタを呼び出して適用する。
	\item[暗黙に]、\tref{型推論}{type-system-type-inference}で適用する。例えば、\expr{arrayInstance.push("foo")}を呼び出す。
\end{description}

型パラメータが付くクラスの定義の内部では、その型パラメータは不定の型となります。\tref{制約}{type-system-type-parameter-constraints}が追加されない限り、コンパイラはその型パラメータはあらゆる型になりうるものと決めつけることになります。その結果、型パラメータの\tref{cast}{expression-cast}を使わなければ、その型のフィールドにアクセスできなくなります。また、\tref{一般化}{type-system-generic}をして適切な制約をつけない限り、その型パラメータの型の新しいインスタンスを生成することもできません。

以下は、型パラメータが使用できる場所についての表です。

\begin{center}
\begin{tabular}{| l | l | l |}
	\hline
	パラメータが付く場所 & 型を適用する場所 & 備考 \\ \hline
	Class & インスタンス作成時 & メンバフィールドにアクセスする際に型を適用することもできる \\
	Enum & インスタンス作成時 & \\
	Enumコンストラクタ & インスタンス作成時 & \\
	関数 & 呼び出し時 & メソッドと名前付きのローカル関数で利用可能	\\
	構造体 & インスタンス作成時 & \\ \hline
\end{tabular}
\end{center}

関数の型パラメータは呼び出し時に適用される、この型パラメータは（制約をつけない限り）あらゆる型を許容します。しかし、一回の呼び出しにつき適用は1つの型のみ可能です。このことは関数が複数の引数を持つ場合に役立ちます。

\haxe{assets/FunctionTypeParameter.hx}

\expr{equals}関数の\expr{expected}と\expr{actual}の引数両方が、\type{T}型になっています。これはすべての\expr{equals}の呼び出しで、2つの引数の型が同じでなければならないことを表しています。コンパイラは最初(両方の引数が\type{Int}型)と2つめ(両方の引数が\type{String}型)の呼び出しは認めていますが、3つ目の呼び出しはコンパイルエラーにします。

\trivia{式の構文内での型パラメータ}{なぜ、\expr{method<String>(x)}のようにメソッドに型パラメータをつけた呼び出しができないのか？という質問をよくいただきます。このときのエラーメッセージはあまり参考になりませんが、これには単純な理由があります。それは、このコードでは、\expr{<}と\expr{>}の両方が2項演算子として構文解析されて、\expr{(method < String) > (x)}と見なされるからです。}

\subsection{制約}
\label{type-system-type-parameter-constraints}

型パラメータは複数の型で制約を与えることができます。

\haxe{assets/Constraints.hx}

\expr{test}メソッドの型パラメータ\type{T}は、\type{Iterable$<$String$>$}と\type{Measurable}の型に制約されます。\type{Measurable}の方は、便宜上\tref{typedef}{type-system-typedef}を使って、\type{Int}型の読み込み専用\tref{プロパティ}{class-field-property}\expr{length}を要求しています。つまり、以下の条件を満たせば、これらの制約と矛盾しません。

\begin{itemize}
	\item \type{Iterable$<$String$>$}である
	\item かつ、\type{Int}型の\expr{length}を持つ
\end{itemize}

7行目では空の配列で、8行目では\type{Array$<$String$>$}で\expr{test}関数を呼び出すことができることを確認しました。しかし、10行目の\type{String}の引数では制約チェックで失敗しています。これは、\type{String}は\type{Iterable$<$T$>$}と矛盾するからです。

\section{ジェネリック}
\label{type-system-generic}

大抵の場合、Haxeコンパイラは型パラメータが付けられていた場合でも、1つのクラスや関数を生成します。これにより自然な抽象化が行われて、ターゲット言語のコードジェネレータは出力先の型パラメータはあらゆる型になりえると思い込むことになります。つまり、生成されたコードで型チェックが働き、動作が邪魔されることがあります。

クラスや関数は、\expr{:generic} \tref{メタデータ}{lf-metadata}で\emph{ジェネリック}属性をつけることで一般化することができます。これにより、コンパイラは型パラメータの組み合わせごとのクラスまたは関数を修飾された名前で書き出します。このような設計は\tref{静的ターゲット}{define-static-target}で出力サイズの巨大化と引き換えに、パフォーマンスが重要なコード部位での速度を得られます。

\haxe{assets/GenericClass.hx}

あまり使わない明示的な\type{MyArray<String>}の型宣言があり、よく使う\tref{型推論}{type-system-type-inference}であつかわせていますが、これが重要です。コンパイラは、コンストラクタの呼び出し時にジェネリッククラスの正確な型な型を知っている必要があります。この\target{JavaScript}出力は以下のような結果になります。

\begin{lstlisting}
(function () { "use strict";
var Main = function() { }
Main.main = function() {
	var a = new MyArray_String();
	var b = new MyArray_Int();
}
var MyArray_Int = function() {
};
var MyArray_String = function() {
};
Main.main();
})();
\end{lstlisting}

\type{MyArray<String>}と\type{MyArray<Int>}は、それぞれ\type{MyArray_String}と\type{MyArray_Int}になっています。これはジェネリック関数でも同じです。

\haxe{assets/GenericFunction.hx}

\target{JavaScript}出力を見れば明白です。

\begin{lstlisting}
(function () { "use strict";
var Main = function() { }
Main.method_Int = function(t) {
}
Main.method_String = function(t) {
}
Main.main = function() {
	Main.method_String("foo");
	Main.method_Int(1);
}
Main.main();
})();
\end{lstlisting}


\subsection{ジェネリック型パラメータのコンストラクト}
\label{type-system-generic-type-parameter-construction}

\define{ジェネリック型パラメータ}{define-generic-type-parameter}{型パラメータを持っているクラスまたはメソッドがジェネリックであるとき、その型パラメータもジェネリックであるという。}

普通の型パラメータでは、\expr{new T()}のようにその型をコンストラクトすることはできません。これは、Haxeが1つの関数を生成するために、そのコンストラクトが意味をなさないからです。しかし、型パラメータがジェネリックの場合は違います。これは、コンパイラはすべての型パラメータの組み合わせに対して別々の関数を生成しています。このため\expr{new T()}の\type{T}を実際の型に置き換えることができます。

\haxe{assets/GenericTypeParameter.hx}

ここでは、\type{T}の実際の型の決定には、\tref{トップダウンの推論}{type-system-top-down-inference}が行われることに注意してください。この方法での型パラメータのコンストラクトを行うには2つの必須事項があります。

\begin{enumerate}
	\item ジェネリックであること
	\item 明示的に、\tref{コンストラクタ}{types-class-constructor}を持つように\tref{制約}{type-system-type-parameter-constraints}されていること
\end{enumerate}

先ほどの例は、1つ目は\expr{make}が\expr{@:generic}メタデータを持っており、2つ目\type{T}が\type{Constructible}に制約されています。\type{String}と\type{haxe.Template}の両方とも1つ\type{String}の引数のコンストラクタを持つのでこの制約に当てはまります。確かにJavascript出力は予測通りのものになっています。

\begin{lstlisting}
var Main = function() { }
Main.__name__ = true;
Main.make_haxe_Template = function() {
	return new haxe.Template("foo");
}
Main.make_String = function() {
	return new String("foo");
}
Main.main = function() {
	var s = Main.make_String();
	var t = Main.make_haxe_Template();
}
\end{lstlisting}

\section{Variance}
\label{type-system-variance}

While variance is relevant in other places, it occurs particularly often with type parameters and often comes as a surprise in this context. It is also very easy to trigger variance errors:

\haxe{assets/Variance.hx}

Apparently, an \type{Array<Child>} cannot be assigned to an \type{Array<Base>}, even though \type{Child} can be assigned to \type{Base}. The reason for this might be somewhat unexpected: It is not allowed because arrays can be written to, e.g. via their \expr{push()} method. It is easy to generate problems by ignoring variance errors:

\haxe{assets/Variance2.hx}

What happens here is that we subvert the type checker by using a \tref{cast}{expression-cast}, thus allowing the assignment in line 12. With that we hold a reference \expr{bases} to the original array, typed as \type{Array<Base>}. This allows pushing another type compatible with \type{Base}, \type{OtherChild}, onto that array. However, our original reference \expr{children} is still of type \type{Array<Child>}, and things go bad when we encounter the \type{OtherChild} instance in one of its elements while iterating.

If \type{Array} had no \expr{push()} method and no other means of modification, the assignment would be safe because no incompatible type could be added to it. We can achieve this in Haxe by restricting the type accordingly using \tref{structural subtyping}{type-system-structural-subtyping}:

\haxe{assets/Variance3.hx}

With \expr{b} being typed as \type{MyArray<Base>} and \type{MyArray} only having a \expr{pop()} method, we can safely assign. There is no method defined on \type{MyArray} which could be used to add incompatible types, it is thus said to be \emph{covariant}.

\define{Covariance}{define-covariance}{A \tref{compound type}{define-compound-type} is considered covariant if its component types can be assigned to less specific components, i.e. if they are only read, but never written.}

\define{Contravariance}{define-contravariance}{A \tref{compound type}{define-compound-type} is considered contravariant if its component types can be assigned to less generic components, i.e. if they are only written, but never read.}




\section{Unification}
\label{type-system-unification}

\todo{Mention toString()/String conversion somewhere in this chapter.}

Unification is the heart of the type system and contributes immensely to the robustness of Haxe programs. It describes the process of checking if a type is compatible to another type.

\define{Unification}{define-unification}{Unification between two types A and B is a directional process which answers the question if A \emph{can be assigned to} B. It may \emph{mutate} either type if it is or has a \tref{monomorph}{types-monomorph}.}

Unification errors are very easy to trigger:

\begin{lstlisting}
class Main {
	static public function main() {
    // Int should be String
		var s:String = 1;
	}
}
\end{lstlisting}
We try to assign a value of type \type{Int} to a variable of type \type{String}, which causes the compiler to try and \emph{unify Int with String}. This is, of course, not allowed and makes the compiler emit the error \expr{Int should be String}.

In this particular case, the unification is triggered by an \emph{assignment}, a context in which the ``is assignable to'' definition is intuitive. It is one of several cases where unification is performed:

\begin{description}
	\item[Assignment:] If \expr{a} is assigned to \expr{b}, the type of \expr{a} is unified with the type of \expr{b}.
	\item[Function call:] We have briefly seen this one while introducing the \tref{function}{types-function} type. In general, the compiler tries to unify the first given argument type with the first expected argument type, the second given argument type with the second expected argument type and so on until all argument types are handled.
	\item[Function return:] Whenever a function has a \expr{return e} expression, the type of \expr{e} is unified with the function return type. If the function has no explicit return type, it is infered to the type of \expr{e} and subsequent \expr{return} expressions are infered against it.
	\item[Array declaration:] The compiler tries to find a minimal type between all given types in an array declaration. Refer to \Fullref{type-system-unification-common-base-type} for details.
	\item[Object declaration:] If an object is declared ``against'' a given type, the compiler unifies each given field type with each expected field type.
	\item[Operator unification:] Certain operators expect certain types which given types are unified against. For instance, the expression \expr{a \&\& b} unifies both \expr{a} and \expr{b} with \type{Bool} and the expression \expr{a == b} unifies \expr{a} with \expr{b}.
\end{description}


\subsection{Between Class/Interface}
\label{type-system-unification-between-classes-and-interfaces}

When defining unification behavior between classes, it is important to remember that unification is directional: We can assign a more specialized class (e.g. a child class) to a generic class (e.g. a parent class), but the reverse is not valid.

The following assignments are allowed:

\begin{itemize}
	\item child class to parent class
	\item class to implementing interface
	\item interface to base interface
\end{itemize}
These rules are transitive, meaning that a child class can also be assigned to the base class of its base class, an interface its base class implements, the base interface of an implementing interface and so on.
\todo{''parent class'' should probably be used here, but I have no idea what it means, so I will refrain from changing it myself.}

\subsection{Structural Subtyping}
\label{type-system-structural-subtyping}

\define{Structural Subtyping}{define-structural-subtyping}{Structural subtyping defines an implicit relation between types that have the same structure.}

In Haxe, structural subtyping is only possible when assigning a class instance to a structure. The following example is part of the \type{Lambda} class of the \tref{Haxe Standard Library}{std}:

\begin{lstlisting}
public static function
empty<T>(it : Iterable<T>):Bool {
	return !it.iterator().hasNext();
}
\end{lstlisting}
The \expr{empty}-method checks if an \type{Iterable} has an element. For this purpose, it is not necessary to know anything about the argument type other than the fact that it is considered an iterable. This allows calling the \expr{empty}-method with any type that unifies with \type{Iterable$<$T$>$}, which applies to a lot of types in the Haxe Standard Library.

This kind of typing can be very convenient, but extensive use may be detrimental to performance on static targets, which is detailed in \Fullref{types-structure-performance}.


\subsection{Monomorphs}
\label{type-system-monomorphs}

Unification of types having or being a \tref{monomorph}{types-monomorph} is detailed in \Fullref{type-system-type-inference}.


\subsection{Function Return}
\label{type-system-unification-function-return}

Unification of function return types may involve the \tref{\type{Void}-type}{types-void} and require a clear definition of what unifies with \type{Void}. With \type{Void} describing the absence of a type, it is not assignable to any other type, not even \type{Dynamic}. This means that if a function is explicitly declared as returning \type{Dynamic}, it must not return \type{Void}.

The opposite applies as well: If a function declares a return type of \type{Void}, it cannot return \type{Dynamic} or any other type. However, this direction of unification is allowed when assigning function types:

\begin{lstlisting}
var func:Void->Void = function() return "foo";
\end{lstlisting}
The right-hand function clearly is of type \type{Void->String}, yet we can assign it to variable \expr{func} of type \type{Void->Void}. This is because the compiler can safely assume that the return type is irrelevant, given that it could not be assigned to any non-\type{Void} type.


\subsection{Common Base Type}
\label{type-system-unification-common-base-type}

Given a set of multiple types, a \emph{common base type} is a type which all types of the set unify against:

\haxe{assets/UnifyMin.hx}
Although \type{Base} is not mentioned, the Haxe Compiler manages to infer it as the common type of \type{Child1} and \type{Child2}. The Haxe Compiler employs this kind of unification in the following situations:

\begin{itemize}
	\item array declarations
	\item \expr{if}/\expr{else}
	\item cases of a \expr{switch}
\end{itemize}




\section{Type Inference}
\label{type-system-type-inference}

The effects of type inference have been seen throughout this document and will continue to be important. A simple example shows type inference at work:

\haxe{assets/TypeInference.hx}
The special construct \expr{\$type} was previously mentioned in order to simplify the explanation of the \Fullref{types-function} type, so let us introduce it officially now:

%TODO: $type
\define[Construct]{\expr{\$type}}{define-dollar-type}{\expr{\$type} is a compile-time mechanism being called like a function, with a single argument. The compiler evaluates the argument expression and then outputs the type of that expression.}

In the example above, the first \expr{\$type} prints \expr{Unknown<0>}. This is a \tref{monomorph}{types-monomorph}, a type that is not yet known. The next line \expr{x = "foo"} assigns a \type{String} literal to \expr{x}, which causes the \tref{unification}{type-system-unification} of the monomorph with \type{String}. We then see that the type of \expr{x} indeed has changed to \type{String}.

Whenever a type other than \Fullref{types-dynamic} is unified with a monomorph, that monomorph \emph{becomes} that type: it \emph{morphs} into that type. Therefore it cannot morph into a different type afterwards, a property expressed in the \emph{mono} part of its name.

Following the rules of unification, type inference can occur in compound types:

\haxe{assets/TypeInference2.hx}
Variable \expr{x} is first initialized to an empty \type{Array}. At this point we can tell that the type of \expr{x} is an array, but we do not yet know the type of the array elements. Consequentially, the type of \expr{x} is \type{Array<Unknown<0>>}. It is only after pushing a \type{String} onto the array that we know the type to be \type{Array<String>}.


\subsection{Top-down Inference}
\label{type-system-top-down-inference}

Most of the time, types are inferred on their own and may then be unified with an expected type. In a few places, however, an expected type may be used to influence inference. We then speak of \emph{top-down inference}.

\define{Expected Type}{define-expected-type}{Expected types occur when the type of an expression is known before that expression has been typed, e.g. because the expression is argument to a function call. They can influence typing of that expression through what is called \tref{top-down inference}{type-system-top-down-inference}.}

A good example are arrays of mixed types. As mentioned in \Fullref{types-dynamic}, the compiler refuses \expr{[1, "foo"]} because it cannot determine an element type. Employing top-down inference, this can be overcome:

\haxe{assets/TopDownInference.hx}

Here, the compiler knows while typing \expr{[1, "foo"]} that the expected type is \type{Array<Dynamic>}, so the element type is \type{Dynamic}. Instead of the usual unification behavior where the compiler would attempt (and fail) to determine a \tref{common base type}{type-system-unification-common-base-type}, the individual elements are typed against and unified with \type{Dynamic}.

We have seen another interesting use of top-down inference when \tref{construction of generic type parameters}{type-system-generic-type-parameter-construction} was introduced:

\haxe{assets/GenericTypeParameter.hx}

The explicit types \type{String} and \type{haxe.Template} are used here to determine the return type of \expr{make}. This works because the method is invoked as \expr{make()}, so we know the return type will be assigned to the variables. Utilizing this information, it is possible to bind the unknown type \type{T} to \type{String} and \type{haxe.Template} respectively.

% this is not really top down inference
%Top-down inference is also utilized when dealing with \tref{enum constructors}{types-enum-constructor}:

%\haxe{assets/TopDownInference2.hx}

%The constructors \expr{TObject} and \expr{TFunction} of type \expr{ValueType} are recognized even though their containing module \type{Type} is not \tref{imported}{Import}. This is possible because the return type of \expr{Type.typeof("foo")} is known to be \expr{ValueType}.


\subsection{Limitations}
\label{type-system-inference-limitations}

Type inference saves a lot of manual type hints when working with local variables, but sometimes the type system still needs some help. In fact, it does not even try to infer the type of a \tref{variable}{class-field-variable} or \tref{property}{class-field-property} field unless it has a direct initialization.

There are also some cases involving recursion where type inference has limitations. If a function calls itself recursively while its type is not (completely) known yet, type inference may infer a wrong, too specialized type.




\section{Modules and Paths}
\label{type-system-modules-and-paths}

\define{Module}{define-module}{All Haxe code is organized in modules, which are addressed using paths. In essence, each .hx file represents a module which may contain several types. A type may be \expr{private}, in which case only its containing module can access it.}

The distinction of a module and its containing type of the same name is blurry by design. In fact, addressing \expr{haxe.ds.StringMap<Int>} can be considered shorthand for \expr{haxe.ds.StringMap.StringMap<Int>}. The latter version consists of four parts:

\begin{enumerate}
	\item the package \expr{haxe.ds}
	\item the module name \expr{StringMap}
	\item the type name \type{StringMap}
	\item the type parameter \type{Int}
\end{enumerate}
If the module and type name are equal, the duplicate can be removed, leading to the \expr{haxe.ds.StringMap<Int>} short version. However, knowing about the extended version helps with understanding how \tref{module sub-types}{type-system-module-sub-types} are addressed.

Paths can be shortened further by using an \tref{import}{type-system-import}, which typically allows omitting the package part of a path. This may lead to usage of unqualified identifiers, for which understanding the \tref{resolution order}{type-system-resolution-order} is required.

\define{Type path}{define-type-path}{The (dot-)path to a type consists of the package, the module name and the type name. Its general form is \expr{pack1.pack2.packN.ModuleName.TypeName}.} 


\subsection{Module Sub-Types}
\label{type-system-module-sub-types}

A module sub-type is a type declared in a module with a different name than that module. This allows a single .hx file to contain multiple types, which can be accessed unqualified from within the module, and by using \expr{package.Module.Type} from other modules:

\begin{lstlisting}
var e:haxe.macro.Expr.ExprDef;
\end{lstlisting}

Here the sub-type \type{ExprDef} within module \expr{haxe.macro.Expr} is accessed. 

The sub-type relation is not reflected at runtime. That is, public sub-types become a member of their containing package, which could lead to conflicts if two modules within the same package try to define the same sub-type. Naturally the Haxe compiler detects these cases and reports them accordingly. In the example above, \type{ExprDef} is generated as \type{haxe.macro.ExprDef}.

Sub-types can also be made private:

\begin{lstlisting}
private class C { ... }
private enum E { ... }
private typedef T { ... }
private abstract A { ... }
\end{lstlisting}

\define{Private type}{define-private-type}{A type can be made private by using the \expr{private} modifier. As a result, the type can only be directly accessed from within the \tref{module}{define-module} it is defined in.

Private types, unlike public ones, do not become a member of their containing package.}

The accessibility of types can be controlled more fine-grained by using \tref{access control}{lf-access-control}.



\subsection{Import}
\label{type-system-import}

If a type path is used multiple times in a .hx file, it might make sense to use an \expr{import} to shorten it. This allows omitting the package when using the type:

\haxe{assets/Import.hx}

With \expr{haxe.ds.StringMap} being imported in the first line, the compiler is able to resolve the unqualified identifier \expr{StringMap} in the \expr{main} function to this package. The module \type{StringMap} is said to be \emph{imported} into the current file.

In this example, we are actually importing a \emph{module}, not just a specific type within that module. This means that all types defined within the imported module are available:

\haxe{assets/Import2.hx}

The type \type{Binop} is an \tref{enum}{types-enum-instance} declared in the module \type{haxe.macro.Expr}, and thus available after the import of said module. If we were to import only a specific type of that module, e.g. \expr{import haxe.macro.Expr.ExprDef}, the program would fail to compile with \expr{Class not found : Binop}.

There several aspects worth knowing about importing:

\begin{itemize}
	\item The bottommost import takes priority (detailed in \Fullref{type-system-resolution-order}).
	\item The \tref{static extension}{lf-static-extension} keyword \expr{using} implies the effect of \expr{import}.
	\item If an enum is imported (directly or as part of a module import), all its \tref{enum constructors}{types-enum-constructor} are also imported (this is what allows the \expr{OpAdd} usage in above example).
\end{itemize}

Furthermore, it is also possible to import \tref{static fields}{class-field} of a class and use them unqualified:

\haxe{assets/Import3.hx}

\todo{Describe import a.*}

Special care has to be taken with field names or local variable names that conflict with a package name: Since they take priority over packages, a local variable named \expr{haxe} blocks off usage the entire \expr{haxe} package.

\subsection{Resolution Order}
\label{type-system-resolution-order}

Resolution order comes into play as soon as unqualified identifiers are involved. These are \tref{expressions}{expression} in the form of \expr{foo()}, \expr{foo = 1} and \expr{foo.field}. The last one in particular includes module paths such as \expr{haxe.ds.StringMap}, where \expr{haxe} is an unqualified identifier.  

We describe the resolution order algorithm here, which depends on the following state:

\begin{itemize}
	\item the delared \tref{local variables}{expression-var} (including function arguments)
	\item the \tref{imported}{type-system-import} modules, types and statics
	\item the available \tref{static extensions}{lf-static-extension}
	\item the kind (static or member) of the current field
	\item the declared member fields on the current class and its parent classes
	\item the declared static fields on the current class
	\item the \tref{expected type}{define-expected-type}
	\item the expression being \expr{untyped} or not
\end{itemize}

\todo{proper label and caption + code/identifier styling for diagram}

\input{assets/tikz/resolution-order.tex}

Given an identifier \expr{i}, the algorithm is as follows:

\begin{enumerate}
	\item If i is \expr{true}, \expr{false}, \expr{this}, \expr{super} or \expr{null}, resolve to the matching constant and halt.
	\item If a local variable named \expr{i} is accessible, resolve to it and halt.
	\item If the current field is static, go to \ref{resolution:static-lookup}.
	\item If the current class or any of its parent classes has a field named \expr{i}, resolve to it and halt.
	\item\label{resolution:static-extension} If a static extension with a first argument of the type of the current class is available, resolve to it and halt.
	\item\label{resolution:static-lookup} If the current class has a static field named \expr{i}, resolve to it and halt.
	\item\label{resolution:enum-ctor} If an enum constructor named \expr{i} is declared on an imported enum, resolve to it and halt.
	\item If a static named \expr{i} is explicitly imported, resolve to it and halt.
	\item If \expr{i} starts with a lower-case character, go to \ref{resolution:untyped}.
	\item\label{resolution:type} If a type named \expr{i} is available, resolve to it and halt.
	\item\label{resolution:untyped} If the expression is not in untyped mode, go to \ref{resolution:failure}
	\item If \expr{i} equals \expr{__this__}, resolve to the \expr{this} constant and halt.
	\item Generate a local variable named \expr{i}, resolve to it and halt.
	\item\label{resolution:failure} Fail
\end{enumerate}

For step \ref{resolution:type}, it is also necessary to define the resolution order of types:

\begin{enumerate}
	\item\label{resolution:import} If a type named \expr{i} is imported (directly or as part of a module), resolve to it and halt.
	\item If the current package contains a module named \expr{i} with a type named \expr{i}, resolve to it and halt.
	\item If a type named \expr{i} is available at top-level, resolve to it and halt.
	\item Fail
\end{enumerate}

For step \ref{resolution:import} of this algorithm as well as steps \ref{resolution:static-extension} and \ref{resolution:enum-ctor} of the previous one, the order of import resolution is important:

\begin{itemize}
	\item Imported modules and static extensions are checked from bottom to top with the first match being picked.
	\item Within a given module, types are checked from top to bottom.
	\item For imports, a match is made if the name equals.
	\item For \tref{static extensions}{lf-static-extension}, a match is made if the name equals and the first argument \tref{unifies}{type-system-unification}. Within a given type being used as static extension, the fields are checked from top to bottom.
\end{itemize}
